   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "accgyro_mpu.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm mpuResetFn,4,4
  20              	 .section .text.mpu6050FindRevision,"ax",%progbits
  21              	 .align 2
  22              	 .thumb
  23              	 .thumb_func
  25              	mpu6050FindRevision:
  26              	.LFB541:
  27              	 .file 1 "../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c"
   1:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** /*
   2:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * This file is part of Cleanflight and Betaflight.
   3:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  *
   4:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * Cleanflight and Betaflight are free software. You can redistribute
   5:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * this software and/or modify this software under the terms of the
   6:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * GNU General Public License as published by the Free Software
   7:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * Foundation, either version 3 of the License, or (at your option)
   8:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * any later version.
   9:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  *
  10:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * Cleanflight and Betaflight are distributed in the hope that they
  11:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * will be useful, but WITHOUT ANY WARRANTY; without even the implied
  12:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  13:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * See the GNU General Public License for more details.
  14:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  *
  15:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * You should have received a copy of the GNU General Public License
  16:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * along with this software.
  17:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  *
  18:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * If not, see <http://www.gnu.org/licenses/>.
  19:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  */
  20:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  21:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include <stdbool.h>
  22:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include <stdint.h>
  23:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include <stdlib.h>
  24:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include <string.h>
  25:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  26:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "platform.h"
  27:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  28:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "build/atomic.h"
  29:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "build/build_config.h"
  30:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "build/debug.h"
  31:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  32:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "common/maths.h"
  33:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "common/utils.h"
  34:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  35:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/bus.h"
  36:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/bus_i2c.h"
  37:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/bus_spi.h"
  38:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/exti.h"
  39:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/io.h"
  40:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/nvic.h"
  41:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/sensor.h"
  42:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/system.h"
  43:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/time.h"
  44:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  45:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro.h"
  46:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_mpu3050.h"
  47:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_mpu6050.h"
  48:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_mpu6500.h"
  49:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_spi_bmi160.h"
  50:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_spi_icm20649.h"
  51:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_spi_icm20689.h"
  52:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_spi_mpu6000.h"
  53:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_spi_mpu6500.h"
  54:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_spi_mpu9250.h"
  55:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #include "drivers/accgyro/accgyro_mpu.h"
  56:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  57:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** mpuResetFnPtr mpuResetFn;
  58:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  59:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef MPU_I2C_INSTANCE
  60:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #define MPU_I2C_INSTANCE I2C_DEVICE
  61:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
  62:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  63:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef MPU_ADDRESS
  64:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #define MPU_ADDRESS             0x68
  65:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
  66:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  67:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #define MPU_INQUIRY_MASK   0x7E
  68:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  69:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_I2C
  70:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** static void mpu6050FindRevision(gyroDev_t *gyro)
  71:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
  28              	 .loc 1 71 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32 0000 80B5     	 push {r7,lr}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 8
  35              	 .cfi_offset 7,-8
  36              	 .cfi_offset 14,-4
  37 0002 86B0     	 sub sp,sp,#24
  38              	.LCFI1:
  39              	 .cfi_def_cfa_offset 32
  40 0004 00AF     	 add r7,sp,#0
  41              	.LCFI2:
  42              	 .cfi_def_cfa_register 7
  43 0006 7860     	 str r0,[r7,#4]
  72:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // There is a map of revision contained in the android source tree which is quite comprehensive
  73:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // See https://android.googlesource.com/kernel/msm.git/+/eaf36994a3992b8f918c18e4f7411e8b2320a3
  74:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
  75:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // determine product ID and revision
  76:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t readBuffer[6];
  77:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     bool ack = busReadRegisterBuffer(&gyro->bus, MPU_RA_XA_OFFS_H, readBuffer, 6);
  44              	 .loc 1 77 0
  45 0008 7B68     	 ldr r3,[r7,#4]
  46 000a 03F11002 	 add r2,r3,#16
  47 000e 07F11003 	 add r3,r7,#16
  48 0012 1046     	 mov r0,r2
  49 0014 0621     	 movs r1,#6
  50 0016 1A46     	 mov r2,r3
  51 0018 0623     	 movs r3,#6
  52 001a FFF7FEFF 	 bl busReadRegisterBuffer
  53 001e 0346     	 mov r3,r0
  54 0020 FB75     	 strb r3,[r7,#23]
  78:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t revision = ((readBuffer[5] & 0x01) << 2) | ((readBuffer[3] & 0x01) << 1) | (readBuffer[
  55              	 .loc 1 78 0
  56 0022 7B7D     	 ldrb r3,[r7,#21]
  57 0024 03F00103 	 and r3,r3,#1
  58 0028 9B00     	 lsls r3,r3,#2
  59 002a DAB2     	 uxtb r2,r3
  60 002c FB7C     	 ldrb r3,[r7,#19]
  61 002e 03F00103 	 and r3,r3,#1
  62 0032 5B00     	 lsls r3,r3,#1
  63 0034 DBB2     	 uxtb r3,r3
  64 0036 1343     	 orrs r3,r3,r2
  65 0038 DAB2     	 uxtb r2,r3
  66 003a 7B7C     	 ldrb r3,[r7,#17]
  67 003c DBB2     	 uxtb r3,r3
  68 003e 03F00103 	 and r3,r3,#1
  69 0042 DBB2     	 uxtb r3,r3
  70 0044 1343     	 orrs r3,r3,r2
  71 0046 DBB2     	 uxtb r3,r3
  72 0048 BB75     	 strb r3,[r7,#22]
  79:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (ack && revision) {
  73              	 .loc 1 79 0
  74 004a FB7D     	 ldrb r3,[r7,#23]
  75 004c 002B     	 cmp r3,#0
  76 004e 22D0     	 beq .L2
  77              	 .loc 1 79 0 is_stmt 0 discriminator 1
  78 0050 BB7D     	 ldrb r3,[r7,#22]
  79 0052 002B     	 cmp r3,#0
  80 0054 1FD0     	 beq .L2
  80:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         // Congrats, these parts are better
  81:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         if (revision == 1) {
  81              	 .loc 1 81 0 is_stmt 1
  82 0056 BB7D     	 ldrb r3,[r7,#22]
  83 0058 012B     	 cmp r3,#1
  84 005a 04D1     	 bne .L3
  82:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             gyro->mpuDetectionResult.resolution = MPU_HALF_RESOLUTION;
  85              	 .loc 1 82 0
  86 005c 7B68     	 ldr r3,[r7,#4]
  87 005e 0022     	 movs r2,#0
  88 0060 83F85A20 	 strb r2,[r3,#90]
  89 0064 16E0     	 b .L4
  90              	.L3:
  83:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         } else if (revision == 2) {
  91              	 .loc 1 83 0
  92 0066 BB7D     	 ldrb r3,[r7,#22]
  93 0068 022B     	 cmp r3,#2
  94 006a 04D1     	 bne .L5
  84:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             gyro->mpuDetectionResult.resolution = MPU_FULL_RESOLUTION;
  95              	 .loc 1 84 0
  96 006c 7B68     	 ldr r3,[r7,#4]
  97 006e 0122     	 movs r2,#1
  98 0070 83F85A20 	 strb r2,[r3,#90]
  99 0074 0EE0     	 b .L4
 100              	.L5:
  85:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         } else if ((revision == 3) || (revision == 7)) {
 101              	 .loc 1 85 0
 102 0076 BB7D     	 ldrb r3,[r7,#22]
 103 0078 032B     	 cmp r3,#3
 104 007a 02D0     	 beq .L6
 105              	 .loc 1 85 0 is_stmt 0 discriminator 1
 106 007c BB7D     	 ldrb r3,[r7,#22]
 107 007e 072B     	 cmp r3,#7
 108 0080 04D1     	 bne .L7
 109              	.L6:
  86:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             gyro->mpuDetectionResult.resolution = MPU_FULL_RESOLUTION;
 110              	 .loc 1 86 0 is_stmt 1
 111 0082 7B68     	 ldr r3,[r7,#4]
 112 0084 0122     	 movs r2,#1
 113 0086 83F85A20 	 strb r2,[r3,#90]
 114 008a 03E0     	 b .L4
 115              	.L7:
  87:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         } else {
  88:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             failureMode(FAILURE_ACC_INCOMPATIBLE);
 116              	 .loc 1 88 0
 117 008c 0320     	 movs r0,#3
 118 008e FFF7FEFF 	 bl failureMode
  81:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             gyro->mpuDetectionResult.resolution = MPU_HALF_RESOLUTION;
 119              	 .loc 1 81 0
 120 0092 2AE0     	 b .L1
 121              	.L4:
 122 0094 29E0     	 b .L1
 123              	.L2:
 124              	.LBB2:
  89:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         }
  90:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     } else {
  91:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         uint8_t productId;
  92:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         ack = busReadRegisterBuffer(&gyro->bus, MPU_RA_PRODUCT_ID, &productId, 1);
 125              	 .loc 1 92 0
 126 0096 7B68     	 ldr r3,[r7,#4]
 127 0098 03F11002 	 add r2,r3,#16
 128 009c 07F10F03 	 add r3,r7,#15
 129 00a0 1046     	 mov r0,r2
 130 00a2 0C21     	 movs r1,#12
 131 00a4 1A46     	 mov r2,r3
 132 00a6 0123     	 movs r3,#1
 133 00a8 FFF7FEFF 	 bl busReadRegisterBuffer
 134 00ac 0346     	 mov r3,r0
 135 00ae FB75     	 strb r3,[r7,#23]
  93:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         revision = productId & 0x0F;
 136              	 .loc 1 93 0
 137 00b0 FB7B     	 ldrb r3,[r7,#15]
 138 00b2 03F00F03 	 and r3,r3,#15
 139 00b6 BB75     	 strb r3,[r7,#22]
  94:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         if (!ack || revision == 0) {
 140              	 .loc 1 94 0
 141 00b8 FB7D     	 ldrb r3,[r7,#23]
 142 00ba 83F00103 	 eor r3,r3,#1
 143 00be DBB2     	 uxtb r3,r3
 144 00c0 002B     	 cmp r3,#0
 145 00c2 02D1     	 bne .L9
 146              	 .loc 1 94 0 is_stmt 0 discriminator 1
 147 00c4 BB7D     	 ldrb r3,[r7,#22]
 148 00c6 002B     	 cmp r3,#0
 149 00c8 03D1     	 bne .L10
 150              	.L9:
  95:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             failureMode(FAILURE_ACC_INCOMPATIBLE);
 151              	 .loc 1 95 0 is_stmt 1
 152 00ca 0320     	 movs r0,#3
 153 00cc FFF7FEFF 	 bl failureMode
 154 00d0 0BE0     	 b .L1
 155              	.L10:
  96:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         } else if (revision == 4) {
 156              	 .loc 1 96 0
 157 00d2 BB7D     	 ldrb r3,[r7,#22]
 158 00d4 042B     	 cmp r3,#4
 159 00d6 04D1     	 bne .L12
  97:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             gyro->mpuDetectionResult.resolution = MPU_HALF_RESOLUTION;
 160              	 .loc 1 97 0
 161 00d8 7B68     	 ldr r3,[r7,#4]
 162 00da 0022     	 movs r2,#0
 163 00dc 83F85A20 	 strb r2,[r3,#90]
 164 00e0 03E0     	 b .L1
 165              	.L12:
  98:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         } else {
  99:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             gyro->mpuDetectionResult.resolution = MPU_FULL_RESOLUTION;
 166              	 .loc 1 99 0
 167 00e2 7B68     	 ldr r3,[r7,#4]
 168 00e4 0122     	 movs r2,#1
 169 00e6 83F85A20 	 strb r2,[r3,#90]
 170              	.L1:
 171              	.LBE2:
 100:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         }
 101:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 102:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 172              	 .loc 1 102 0
 173 00ea 1837     	 adds r7,r7,#24
 174              	.LCFI3:
 175              	 .cfi_def_cfa_offset 8
 176 00ec BD46     	 mov sp,r7
 177              	.LCFI4:
 178              	 .cfi_def_cfa_register 13
 179              	 
 180 00ee 80BD     	 pop {r7,pc}
 181              	 .cfi_endproc
 182              	.LFE541:
 184              	 .section .text.mpuAccRead,"ax",%progbits
 185              	 .align 2
 186              	 .global mpuAccRead
 187              	 .thumb
 188              	 .thumb_func
 190              	mpuAccRead:
 191              	.LFB542:
 103:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 104:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 105:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** /*
 106:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  * Gyro interrupt service routine
 107:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****  */
 108:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #if defined(MPU_INT_EXTI)
 109:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** static void mpuIntExtiHandler(extiCallbackRec_t *cb)
 110:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 111:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef DEBUG_MPU_DATA_READY_INTERRUPT
 112:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     static uint32_t lastCalledAtUs = 0;
 113:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const uint32_t nowUs = micros();
 114:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     debug[0] = (uint16_t)(nowUs - lastCalledAtUs);
 115:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     lastCalledAtUs = nowUs;
 116:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 117:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyroDev_t *gyro = container_of(cb, gyroDev_t, exti);
 118:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->dataReady = true;
 119:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef DEBUG_MPU_DATA_READY_INTERRUPT
 120:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const uint32_t now2Us = micros();
 121:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     debug[1] = (uint16_t)(now2Us - nowUs);
 122:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 123:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 124:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 125:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** static void mpuIntExtiInit(gyroDev_t *gyro)
 126:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 127:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (gyro->mpuIntExtiTag == IO_TAG_NONE) {
 128:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return;
 129:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 130:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 131:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const IO_t mpuIntIO = IOGetByTag(gyro->mpuIntExtiTag);
 132:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 133:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef ENSURE_MPU_DATA_READY_IS_LOW
 134:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t status = IORead(mpuIntIO);
 135:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (status) {
 136:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return;
 137:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 138:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 139:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 140:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #if defined (STM32F7)
 141:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     IOInit(mpuIntIO, OWNER_MPU_EXTI, 0);
 142:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     EXTIHandlerInit(&gyro->exti, mpuIntExtiHandler);
 143:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     EXTIConfig(mpuIntIO, &gyro->exti, NVIC_PRIO_MPU_INT_EXTI, IO_CONFIG(GPIO_MODE_INPUT,0,GPIO_NOPU
 144:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #else
 145:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     IOInit(mpuIntIO, OWNER_MPU_EXTI, 0);
 146:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     IOConfigGPIO(mpuIntIO, IOCFG_IN_FLOATING);   // TODO - maybe pullup / pulldown ?
 147:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 148:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     EXTIHandlerInit(&gyro->exti, mpuIntExtiHandler);
 149:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     EXTIConfig(mpuIntIO, &gyro->exti, NVIC_PRIO_MPU_INT_EXTI, EXTI_Trigger_Rising);
 150:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 151:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     EXTIEnable(mpuIntIO, true);
 152:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 153:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif // MPU_INT_EXTI
 154:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 155:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** bool mpuAccRead(accDev_t *acc)
 156:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 192              	 .loc 1 156 0
 193              	 .cfi_startproc
 194              	 
 195              	 
 196 0000 80B5     	 push {r7,lr}
 197              	.LCFI5:
 198              	 .cfi_def_cfa_offset 8
 199              	 .cfi_offset 7,-8
 200              	 .cfi_offset 14,-4
 201 0002 84B0     	 sub sp,sp,#16
 202              	.LCFI6:
 203              	 .cfi_def_cfa_offset 24
 204 0004 00AF     	 add r7,sp,#0
 205              	.LCFI7:
 206              	 .cfi_def_cfa_register 7
 207 0006 7860     	 str r0,[r7,#4]
 157:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t data[6];
 158:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 159:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const bool ack = busReadRegisterBuffer(&acc->bus, MPU_RA_ACCEL_XOUT_H, data, 6);
 208              	 .loc 1 159 0
 209 0008 7B68     	 ldr r3,[r7,#4]
 210 000a 03F10802 	 add r2,r3,#8
 211 000e 07F10803 	 add r3,r7,#8
 212 0012 1046     	 mov r0,r2
 213 0014 3B21     	 movs r1,#59
 214 0016 1A46     	 mov r2,r3
 215 0018 0623     	 movs r3,#6
 216 001a FFF7FEFF 	 bl busReadRegisterBuffer
 217 001e 0346     	 mov r3,r0
 218 0020 FB73     	 strb r3,[r7,#15]
 160:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (!ack) {
 219              	 .loc 1 160 0
 220 0022 FB7B     	 ldrb r3,[r7,#15]
 221 0024 83F00103 	 eor r3,r3,#1
 222 0028 DBB2     	 uxtb r3,r3
 223 002a 002B     	 cmp r3,#0
 224 002c 01D0     	 beq .L14
 161:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return false;
 225              	 .loc 1 161 0
 226 002e 0023     	 movs r3,#0
 227 0030 1EE0     	 b .L16
 228              	.L14:
 162:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 163:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 164:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     acc->ADCRaw[X] = (int16_t)((data[0] << 8) | data[1]);
 229              	 .loc 1 164 0
 230 0032 3B7A     	 ldrb r3,[r7,#8]
 231 0034 1B02     	 lsls r3,r3,#8
 232 0036 9AB2     	 uxth r2,r3
 233 0038 7B7A     	 ldrb r3,[r7,#9]
 234 003a 9BB2     	 uxth r3,r3
 235 003c 1343     	 orrs r3,r3,r2
 236 003e 9AB2     	 uxth r2,r3
 237 0040 7B68     	 ldr r3,[r7,#4]
 238 0042 A3F81320 	 strh r2,[r3,#19]
 165:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     acc->ADCRaw[Y] = (int16_t)((data[2] << 8) | data[3]);
 239              	 .loc 1 165 0
 240 0046 BB7A     	 ldrb r3,[r7,#10]
 241 0048 1B02     	 lsls r3,r3,#8
 242 004a 9AB2     	 uxth r2,r3
 243 004c FB7A     	 ldrb r3,[r7,#11]
 244 004e 9BB2     	 uxth r3,r3
 245 0050 1343     	 orrs r3,r3,r2
 246 0052 9AB2     	 uxth r2,r3
 247 0054 7B68     	 ldr r3,[r7,#4]
 248 0056 A3F81520 	 strh r2,[r3,#21]
 166:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     acc->ADCRaw[Z] = (int16_t)((data[4] << 8) | data[5]);
 249              	 .loc 1 166 0
 250 005a 3B7B     	 ldrb r3,[r7,#12]
 251 005c 1B02     	 lsls r3,r3,#8
 252 005e 9AB2     	 uxth r2,r3
 253 0060 7B7B     	 ldrb r3,[r7,#13]
 254 0062 9BB2     	 uxth r3,r3
 255 0064 1343     	 orrs r3,r3,r2
 256 0066 9AB2     	 uxth r2,r3
 257 0068 7B68     	 ldr r3,[r7,#4]
 258 006a A3F81720 	 strh r2,[r3,#23]
 167:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 168:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     return true;
 259              	 .loc 1 168 0
 260 006e 0123     	 movs r3,#1
 261              	.L16:
 169:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 262              	 .loc 1 169 0 discriminator 1
 263 0070 1846     	 mov r0,r3
 264 0072 1037     	 adds r7,r7,#16
 265              	.LCFI8:
 266              	 .cfi_def_cfa_offset 8
 267 0074 BD46     	 mov sp,r7
 268              	.LCFI9:
 269              	 .cfi_def_cfa_register 13
 270              	 
 271 0076 80BD     	 pop {r7,pc}
 272              	 .cfi_endproc
 273              	.LFE542:
 275              	 .section .text.mpuGyroRead,"ax",%progbits
 276              	 .align 2
 277              	 .global mpuGyroRead
 278              	 .thumb
 279              	 .thumb_func
 281              	mpuGyroRead:
 282              	.LFB543:
 170:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 171:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** bool mpuGyroRead(gyroDev_t *gyro)
 172:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 283              	 .loc 1 172 0
 284              	 .cfi_startproc
 285              	 
 286              	 
 287 0000 80B5     	 push {r7,lr}
 288              	.LCFI10:
 289              	 .cfi_def_cfa_offset 8
 290              	 .cfi_offset 7,-8
 291              	 .cfi_offset 14,-4
 292 0002 84B0     	 sub sp,sp,#16
 293              	.LCFI11:
 294              	 .cfi_def_cfa_offset 24
 295 0004 00AF     	 add r7,sp,#0
 296              	.LCFI12:
 297              	 .cfi_def_cfa_register 7
 298 0006 7860     	 str r0,[r7,#4]
 173:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t data[6];
 174:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 175:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const bool ack = busReadRegisterBuffer(&gyro->bus, MPU_RA_GYRO_XOUT_H, data, 6);
 299              	 .loc 1 175 0
 300 0008 7B68     	 ldr r3,[r7,#4]
 301 000a 03F11002 	 add r2,r3,#16
 302 000e 07F10803 	 add r3,r7,#8
 303 0012 1046     	 mov r0,r2
 304 0014 4321     	 movs r1,#67
 305 0016 1A46     	 mov r2,r3
 306 0018 0623     	 movs r3,#6
 307 001a FFF7FEFF 	 bl busReadRegisterBuffer
 308 001e 0346     	 mov r3,r0
 309 0020 FB73     	 strb r3,[r7,#15]
 176:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (!ack) {
 310              	 .loc 1 176 0
 311 0022 FB7B     	 ldrb r3,[r7,#15]
 312 0024 83F00103 	 eor r3,r3,#1
 313 0028 DBB2     	 uxtb r3,r3
 314 002a 002B     	 cmp r3,#0
 315 002c 01D0     	 beq .L18
 177:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return false;
 316              	 .loc 1 177 0
 317 002e 0023     	 movs r3,#0
 318 0030 1EE0     	 b .L20
 319              	.L18:
 178:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 179:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 180:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->gyroADCRaw[X] = (int16_t)((data[0] << 8) | data[1]);
 320              	 .loc 1 180 0
 321 0032 3B7A     	 ldrb r3,[r7,#8]
 322 0034 1B02     	 lsls r3,r3,#8
 323 0036 9AB2     	 uxth r2,r3
 324 0038 7B7A     	 ldrb r3,[r7,#9]
 325 003a 9BB2     	 uxth r3,r3
 326 003c 1343     	 orrs r3,r3,r2
 327 003e 9AB2     	 uxth r2,r3
 328 0040 7B68     	 ldr r3,[r7,#4]
 329 0042 A3F84D20 	 strh r2,[r3,#77]
 181:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->gyroADCRaw[Y] = (int16_t)((data[2] << 8) | data[3]);
 330              	 .loc 1 181 0
 331 0046 BB7A     	 ldrb r3,[r7,#10]
 332 0048 1B02     	 lsls r3,r3,#8
 333 004a 9AB2     	 uxth r2,r3
 334 004c FB7A     	 ldrb r3,[r7,#11]
 335 004e 9BB2     	 uxth r3,r3
 336 0050 1343     	 orrs r3,r3,r2
 337 0052 9AB2     	 uxth r2,r3
 338 0054 7B68     	 ldr r3,[r7,#4]
 339 0056 A3F84F20 	 strh r2,[r3,#79]
 182:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->gyroADCRaw[Z] = (int16_t)((data[4] << 8) | data[5]);
 340              	 .loc 1 182 0
 341 005a 3B7B     	 ldrb r3,[r7,#12]
 342 005c 1B02     	 lsls r3,r3,#8
 343 005e 9AB2     	 uxth r2,r3
 344 0060 7B7B     	 ldrb r3,[r7,#13]
 345 0062 9BB2     	 uxth r3,r3
 346 0064 1343     	 orrs r3,r3,r2
 347 0066 9AB2     	 uxth r2,r3
 348 0068 7B68     	 ldr r3,[r7,#4]
 349 006a A3F85120 	 strh r2,[r3,#81]
 183:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 184:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     return true;
 350              	 .loc 1 184 0
 351 006e 0123     	 movs r3,#1
 352              	.L20:
 185:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 353              	 .loc 1 185 0 discriminator 1
 354 0070 1846     	 mov r0,r3
 355 0072 1037     	 adds r7,r7,#16
 356              	.LCFI13:
 357              	 .cfi_def_cfa_offset 8
 358 0074 BD46     	 mov sp,r7
 359              	.LCFI14:
 360              	 .cfi_def_cfa_register 13
 361              	 
 362 0076 80BD     	 pop {r7,pc}
 363              	 .cfi_endproc
 364              	.LFE543:
 366              	 .section .text.mpuGyroReadSPI,"ax",%progbits
 367              	 .align 2
 368              	 .global mpuGyroReadSPI
 369              	 .thumb
 370              	 .thumb_func
 372              	mpuGyroReadSPI:
 373              	.LFB544:
 186:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 187:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** bool mpuGyroReadSPI(gyroDev_t *gyro)
 188:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 374              	 .loc 1 188 0
 375              	 .cfi_startproc
 376              	 
 377              	 
 378 0000 80B5     	 push {r7,lr}
 379              	.LCFI15:
 380              	 .cfi_def_cfa_offset 8
 381              	 .cfi_offset 7,-8
 382              	 .cfi_offset 14,-4
 383 0002 84B0     	 sub sp,sp,#16
 384              	.LCFI16:
 385              	 .cfi_def_cfa_offset 24
 386 0004 00AF     	 add r7,sp,#0
 387              	.LCFI17:
 388              	 .cfi_def_cfa_register 7
 389 0006 7860     	 str r0,[r7,#4]
 189:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     static const uint8_t dataToSend[7] = {MPU_RA_GYRO_XOUT_H | 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
 190:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t data[7];
 191:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 192:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const bool ack = spiBusTransfer(&gyro->bus, dataToSend, data, 7);
 390              	 .loc 1 192 0
 391 0008 7B68     	 ldr r3,[r7,#4]
 392 000a 03F11002 	 add r2,r3,#16
 393 000e 07F10803 	 add r3,r7,#8
 394 0012 1046     	 mov r0,r2
 395 0014 1849     	 ldr r1,.L25
 396 0016 1A46     	 mov r2,r3
 397 0018 0723     	 movs r3,#7
 398 001a FFF7FEFF 	 bl spiBusTransfer
 399 001e 0346     	 mov r3,r0
 400 0020 FB73     	 strb r3,[r7,#15]
 193:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (!ack) {
 401              	 .loc 1 193 0
 402 0022 FB7B     	 ldrb r3,[r7,#15]
 403 0024 83F00103 	 eor r3,r3,#1
 404 0028 DBB2     	 uxtb r3,r3
 405 002a 002B     	 cmp r3,#0
 406 002c 01D0     	 beq .L22
 194:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return false;
 407              	 .loc 1 194 0
 408 002e 0023     	 movs r3,#0
 409 0030 1EE0     	 b .L24
 410              	.L22:
 195:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 196:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 197:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->gyroADCRaw[X] = (int16_t)((data[1] << 8) | data[2]);
 411              	 .loc 1 197 0
 412 0032 7B7A     	 ldrb r3,[r7,#9]
 413 0034 1B02     	 lsls r3,r3,#8
 414 0036 9AB2     	 uxth r2,r3
 415 0038 BB7A     	 ldrb r3,[r7,#10]
 416 003a 9BB2     	 uxth r3,r3
 417 003c 1343     	 orrs r3,r3,r2
 418 003e 9AB2     	 uxth r2,r3
 419 0040 7B68     	 ldr r3,[r7,#4]
 420 0042 A3F84D20 	 strh r2,[r3,#77]
 198:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->gyroADCRaw[Y] = (int16_t)((data[3] << 8) | data[4]);
 421              	 .loc 1 198 0
 422 0046 FB7A     	 ldrb r3,[r7,#11]
 423 0048 1B02     	 lsls r3,r3,#8
 424 004a 9AB2     	 uxth r2,r3
 425 004c 3B7B     	 ldrb r3,[r7,#12]
 426 004e 9BB2     	 uxth r3,r3
 427 0050 1343     	 orrs r3,r3,r2
 428 0052 9AB2     	 uxth r2,r3
 429 0054 7B68     	 ldr r3,[r7,#4]
 430 0056 A3F84F20 	 strh r2,[r3,#79]
 199:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->gyroADCRaw[Z] = (int16_t)((data[5] << 8) | data[6]);
 431              	 .loc 1 199 0
 432 005a 7B7B     	 ldrb r3,[r7,#13]
 433 005c 1B02     	 lsls r3,r3,#8
 434 005e 9AB2     	 uxth r2,r3
 435 0060 BB7B     	 ldrb r3,[r7,#14]
 436 0062 9BB2     	 uxth r3,r3
 437 0064 1343     	 orrs r3,r3,r2
 438 0066 9AB2     	 uxth r2,r3
 439 0068 7B68     	 ldr r3,[r7,#4]
 440 006a A3F85120 	 strh r2,[r3,#81]
 200:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 201:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     return true;
 441              	 .loc 1 201 0
 442 006e 0123     	 movs r3,#1
 443              	.L24:
 202:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 444              	 .loc 1 202 0 discriminator 1
 445 0070 1846     	 mov r0,r3
 446 0072 1037     	 adds r7,r7,#16
 447              	.LCFI18:
 448              	 .cfi_def_cfa_offset 8
 449 0074 BD46     	 mov sp,r7
 450              	.LCFI19:
 451              	 .cfi_def_cfa_register 13
 452              	 
 453 0076 80BD     	 pop {r7,pc}
 454              	.L26:
 455              	 .align 2
 456              	.L25:
 457 0078 00000000 	 .word dataToSend.12879
 458              	 .cfi_endproc
 459              	.LFE544:
 461              	 .section .text.detectSPISensorsAndUpdateDetectionResult,"ax",%progbits
 462              	 .align 2
 463              	 .thumb
 464              	 .thumb_func
 466              	detectSPISensorsAndUpdateDetectionResult:
 467              	.LFB545:
 203:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 204:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_SPI
 205:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** static bool detectSPISensorsAndUpdateDetectionResult(gyroDev_t *gyro)
 206:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 468              	 .loc 1 206 0
 469              	 .cfi_startproc
 470              	 
 471              	 
 472              	 
 473 0000 80B4     	 push {r7}
 474              	.LCFI20:
 475              	 .cfi_def_cfa_offset 4
 476              	 .cfi_offset 7,-4
 477 0002 85B0     	 sub sp,sp,#20
 478              	.LCFI21:
 479              	 .cfi_def_cfa_offset 24
 480 0004 00AF     	 add r7,sp,#0
 481              	.LCFI22:
 482              	 .cfi_def_cfa_register 7
 483 0006 7860     	 str r0,[r7,#4]
 207:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     UNUSED(gyro); // since there are FCs which have gyro on I2C but other devices on SPI
 208:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 209:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t sensor = MPU_NONE;
 484              	 .loc 1 209 0
 485 0008 0023     	 movs r3,#0
 486 000a FB73     	 strb r3,[r7,#15]
 210:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     UNUSED(sensor);
 211:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 212:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // note, when USE_DUAL_GYRO is enabled the gyro->bus must already be initialised.
 213:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 214:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_GYRO_SPI_MPU6000
 215:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef USE_DUAL_GYRO
 216:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     spiBusSetInstance(&gyro->bus, MPU6000_SPI_INSTANCE);
 217:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 218:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef MPU6000_CS_PIN
 219:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.busdev_u.spi.csnPin = gyro->bus.busdev_u.spi.csnPin == IO_NONE ? IOGetByTag(IO_TAG(MP
 220:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 221:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     sensor = mpu6000SpiDetect(&gyro->bus);
 222:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (sensor != MPU_NONE) {
 223:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuDetectionResult.sensor = sensor;
 224:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return true;
 225:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 226:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 227:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 228:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_GYRO_SPI_MPU6500
 229:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef USE_DUAL_GYRO
 230:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     spiBusSetInstance(&gyro->bus, MPU6500_SPI_INSTANCE);
 231:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 232:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef MPU6500_CS_PIN
 233:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.busdev_u.spi.csnPin = gyro->bus.busdev_u.spi.csnPin == IO_NONE ? IOGetByTag(IO_TAG(MP
 234:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 235:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     sensor = mpu6500SpiDetect(&gyro->bus);
 236:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // some targets using MPU_9250_SPI, ICM_20608_SPI or ICM_20602_SPI state sensor is MPU_65xx_SPI
 237:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (sensor != MPU_NONE) {
 238:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuDetectionResult.sensor = sensor;
 239:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return true;
 240:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 241:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 242:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 243:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef  USE_GYRO_SPI_MPU9250
 244:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef USE_DUAL_GYRO
 245:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     spiBusSetInstance(&gyro->bus, MPU9250_SPI_INSTANCE);
 246:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 247:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef MPU9250_CS_PIN
 248:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.busdev_u.spi.csnPin = gyro->bus.busdev_u.spi.csnPin == IO_NONE ? IOGetByTag(IO_TAG(MP
 249:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 250:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     sensor = mpu9250SpiDetect(&gyro->bus);
 251:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (sensor != MPU_NONE) {
 252:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuDetectionResult.sensor = sensor;
 253:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuConfiguration.resetFn = mpu9250SpiResetGyro;
 254:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return true;
 255:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 256:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 257:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 258:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_GYRO_SPI_ICM20649
 259:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef ICM20649_SPI_INSTANCE
 260:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     spiBusSetInstance(&gyro->bus, ICM20649_SPI_INSTANCE);
 261:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 262:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef ICM20649_CS_PIN
 263:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.busdev_u.spi.csnPin = gyro->bus.busdev_u.spi.csnPin == IO_NONE ? IOGetByTag(IO_TAG(IC
 264:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 265:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     sensor = icm20649SpiDetect(&gyro->bus);
 266:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (sensor != MPU_NONE) {
 267:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuDetectionResult.sensor = sensor;
 268:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return true;
 269:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 270:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 271:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 272:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_GYRO_SPI_ICM20689
 273:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef USE_DUAL_GYRO
 274:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     spiBusSetInstance(&gyro->bus, ICM20689_SPI_INSTANCE);
 275:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 276:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef ICM20689_CS_PIN
 277:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.busdev_u.spi.csnPin = gyro->bus.busdev_u.spi.csnPin == IO_NONE ? IOGetByTag(IO_TAG(IC
 278:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 279:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     sensor = icm20689SpiDetect(&gyro->bus);
 280:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // icm20689SpiDetect detects ICM20602 and ICM20689
 281:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (sensor != MPU_NONE) {
 282:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuDetectionResult.sensor = sensor;
 283:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return true;
 284:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 285:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 286:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 287:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_ACCGYRO_BMI160
 288:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifndef USE_DUAL_GYRO
 289:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     spiBusSetInstance(&gyro->bus, BMI160_SPI_INSTANCE);
 290:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 291:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef BMI160_CS_PIN
 292:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.busdev_u.spi.csnPin = gyro->bus.busdev_u.spi.csnPin == IO_NONE ? IOGetByTag(IO_TAG(BM
 293:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 294:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     sensor = bmi160Detect(&gyro->bus);
 295:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (sensor != MPU_NONE) {
 296:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->mpuDetectionResult.sensor = sensor;
 297:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return true;
 298:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 299:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 300:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 301:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     return false;
 487              	 .loc 1 301 0
 488 000c 0023     	 movs r3,#0
 302:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 489              	 .loc 1 302 0
 490 000e 1846     	 mov r0,r3
 491 0010 1437     	 adds r7,r7,#20
 492              	.LCFI23:
 493              	 .cfi_def_cfa_offset 4
 494 0012 BD46     	 mov sp,r7
 495              	.LCFI24:
 496              	 .cfi_def_cfa_register 13
 497              	 
 498 0014 5DF8047B 	 ldr r7,[sp],#4
 499              	.LCFI25:
 500              	 .cfi_restore 7
 501              	 .cfi_def_cfa_offset 0
 502 0018 7047     	 bx lr
 503              	 .cfi_endproc
 504              	.LFE545:
 506 001a 00BF     	 .section .text.mpuDetect,"ax",%progbits
 507              	 .align 2
 508              	 .global mpuDetect
 509              	 .thumb
 510              	 .thumb_func
 512              	mpuDetect:
 513              	.LFB546:
 303:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 304:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 305:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** void mpuDetect(gyroDev_t *gyro)
 306:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 514              	 .loc 1 306 0
 515              	 .cfi_startproc
 516              	 
 517              	 
 518 0000 80B5     	 push {r7,lr}
 519              	.LCFI26:
 520              	 .cfi_def_cfa_offset 8
 521              	 .cfi_offset 7,-8
 522              	 .cfi_offset 14,-4
 523 0002 84B0     	 sub sp,sp,#16
 524              	.LCFI27:
 525              	 .cfi_def_cfa_offset 24
 526 0004 00AF     	 add r7,sp,#0
 527              	.LCFI28:
 528              	 .cfi_def_cfa_register 7
 529 0006 7860     	 str r0,[r7,#4]
 307:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     // MPU datasheet specifies 30ms.
 308:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     delay(35);
 530              	 .loc 1 308 0
 531 0008 2320     	 movs r0,#35
 532 000a FFF7FEFF 	 bl delay
 309:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 310:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_I2C
 311:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (gyro->bus.bustype == BUSTYPE_NONE) {
 533              	 .loc 1 311 0
 534 000e 7B68     	 ldr r3,[r7,#4]
 535 0010 1B7C     	 ldrb r3,[r3,#16]
 536 0012 002B     	 cmp r3,#0
 537 0014 02D1     	 bne .L30
 312:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         // if no bustype is selected try I2C first.
 313:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->bus.bustype = BUSTYPE_I2C;
 538              	 .loc 1 313 0
 539 0016 7B68     	 ldr r3,[r7,#4]
 540 0018 0122     	 movs r2,#1
 541 001a 1A74     	 strb r2,[r3,#16]
 542              	.L30:
 314:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 315:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 316:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (gyro->bus.bustype == BUSTYPE_I2C) {
 543              	 .loc 1 316 0
 544 001c 7B68     	 ldr r3,[r7,#4]
 545 001e 1B7C     	 ldrb r3,[r3,#16]
 546 0020 012B     	 cmp r3,#1
 547 0022 4ED1     	 bne .L31
 548              	.LBB3:
 317:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->bus.busdev_u.i2c.device = MPU_I2C_INSTANCE;
 549              	 .loc 1 317 0
 550 0024 7B68     	 ldr r3,[r7,#4]
 551 0026 0422     	 movs r2,#4
 552 0028 5A74     	 strb r2,[r3,#17]
 318:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         gyro->bus.busdev_u.i2c.address = MPU_ADDRESS;
 553              	 .loc 1 318 0
 554 002a 7B68     	 ldr r3,[r7,#4]
 555 002c 6922     	 movs r2,#105
 556 002e 9A74     	 strb r2,[r3,#18]
 319:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 320:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         uint8_t sig = 0;
 557              	 .loc 1 320 0
 558 0030 0023     	 movs r3,#0
 559 0032 BB73     	 strb r3,[r7,#14]
 321:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         bool ack = busReadRegisterBuffer(&gyro->bus, MPU_RA_WHO_AM_I, &sig, 1);
 560              	 .loc 1 321 0
 561 0034 7B68     	 ldr r3,[r7,#4]
 562 0036 03F11002 	 add r2,r3,#16
 563 003a 07F10E03 	 add r3,r7,#14
 564 003e 1046     	 mov r0,r2
 565 0040 7521     	 movs r1,#117
 566 0042 1A46     	 mov r2,r3
 567 0044 0123     	 movs r3,#1
 568 0046 FFF7FEFF 	 bl busReadRegisterBuffer
 569 004a 0346     	 mov r3,r0
 570 004c FB73     	 strb r3,[r7,#15]
 322:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 323:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         if (ack) {
 571              	 .loc 1 323 0
 572 004e FB7B     	 ldrb r3,[r7,#15]
 573 0050 002B     	 cmp r3,#0
 574 0052 36D0     	 beq .L31
 575              	.LBB4:
 324:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             // If an MPU3050 is connected sig will contain 0.
 325:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             uint8_t inquiryResult;
 326:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             ack = busReadRegisterBuffer(&gyro->bus, MPU_RA_WHO_AM_I_LEGACY, &inquiryResult, 1);
 576              	 .loc 1 326 0
 577 0054 7B68     	 ldr r3,[r7,#4]
 578 0056 03F11002 	 add r2,r3,#16
 579 005a 07F10D03 	 add r3,r7,#13
 580 005e 1046     	 mov r0,r2
 581 0060 0021     	 movs r1,#0
 582 0062 1A46     	 mov r2,r3
 583 0064 0123     	 movs r3,#1
 584 0066 FFF7FEFF 	 bl busReadRegisterBuffer
 585 006a 0346     	 mov r3,r0
 586 006c FB73     	 strb r3,[r7,#15]
 327:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             inquiryResult &= MPU_INQUIRY_MASK;
 587              	 .loc 1 327 0
 588 006e 7B7B     	 ldrb r3,[r7,#13]
 589 0070 03F07E03 	 and r3,r3,#126
 590 0074 DBB2     	 uxtb r3,r3
 591 0076 7B73     	 strb r3,[r7,#13]
 328:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             if (ack && inquiryResult == MPUx0x0_WHO_AM_I_CONST) {
 592              	 .loc 1 328 0
 593 0078 FB7B     	 ldrb r3,[r7,#15]
 594 007a 002B     	 cmp r3,#0
 595 007c 07D0     	 beq .L33
 596              	 .loc 1 328 0 is_stmt 0 discriminator 1
 597 007e 7B7B     	 ldrb r3,[r7,#13]
 598 0080 682B     	 cmp r3,#104
 599 0082 04D1     	 bne .L33
 329:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 gyro->mpuDetectionResult.sensor = MPU_3050;
 600              	 .loc 1 329 0 is_stmt 1
 601 0084 7B68     	 ldr r3,[r7,#4]
 602 0086 0122     	 movs r2,#1
 603 0088 83F85920 	 strb r2,[r3,#89]
 330:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 return;
 604              	 .loc 1 330 0
 605 008c 1FE0     	 b .L29
 606              	.L33:
 331:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             }
 332:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 333:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             sig &= MPU_INQUIRY_MASK;
 607              	 .loc 1 333 0
 608 008e BB7B     	 ldrb r3,[r7,#14]
 609 0090 03F07E03 	 and r3,r3,#126
 610 0094 DBB2     	 uxtb r3,r3
 611 0096 BB73     	 strb r3,[r7,#14]
 334:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             if (sig == MPUx0x0_WHO_AM_I_CONST) {
 612              	 .loc 1 334 0
 613 0098 BB7B     	 ldrb r3,[r7,#14]
 614 009a 682B     	 cmp r3,#104
 615 009c 07D1     	 bne .L35
 335:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 gyro->mpuDetectionResult.sensor = MPU_60x0;
 616              	 .loc 1 335 0
 617 009e 7B68     	 ldr r3,[r7,#4]
 618 00a0 0222     	 movs r2,#2
 619 00a2 83F85920 	 strb r2,[r3,#89]
 336:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 mpu6050FindRevision(gyro);
 620              	 .loc 1 336 0
 621 00a6 7868     	 ldr r0,[r7,#4]
 622 00a8 FFF7FEFF 	 bl mpu6050FindRevision
 623 00ac 07E0     	 b .L36
 624              	.L35:
 337:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             } else if (sig == MPU6500_WHO_AM_I_CONST) {
 625              	 .loc 1 337 0
 626 00ae BB7B     	 ldrb r3,[r7,#14]
 627 00b0 702B     	 cmp r3,#112
 628 00b2 04D1     	 bne .L36
 338:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 gyro->mpuDetectionResult.sensor = MPU_65xx_I2C;
 629              	 .loc 1 338 0
 630 00b4 7B68     	 ldr r3,[r7,#4]
 631 00b6 0422     	 movs r2,#4
 632 00b8 83F85920 	 strb r2,[r3,#89]
 339:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             }
 340:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             return;
 633              	 .loc 1 340 0
 634 00bc 07E0     	 b .L29
 635              	.L36:
 636 00be 00BF     	 nop
 637 00c0 05E0     	 b .L29
 638              	.L31:
 639              	.LBE4:
 640              	.LBE3:
 341:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         }
 342:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 343:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 344:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 345:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_SPI
 346:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     gyro->bus.bustype = BUSTYPE_SPI;
 641              	 .loc 1 346 0
 642 00c2 7B68     	 ldr r3,[r7,#4]
 643 00c4 0222     	 movs r2,#2
 644 00c6 1A74     	 strb r2,[r3,#16]
 347:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     detectSPISensorsAndUpdateDetectionResult(gyro);
 645              	 .loc 1 347 0
 646 00c8 7868     	 ldr r0,[r7,#4]
 647 00ca FFF7FEFF 	 bl detectSPISensorsAndUpdateDetectionResult
 648              	.L29:
 348:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 349:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 649              	 .loc 1 349 0
 650 00ce 1037     	 adds r7,r7,#16
 651              	.LCFI29:
 652              	 .cfi_def_cfa_offset 8
 653 00d0 BD46     	 mov sp,r7
 654              	.LCFI30:
 655              	 .cfi_def_cfa_register 13
 656              	 
 657 00d2 80BD     	 pop {r7,pc}
 658              	 .cfi_endproc
 659              	.LFE546:
 661              	 .section .text.mpuGyroInit,"ax",%progbits
 662              	 .align 2
 663              	 .global mpuGyroInit
 664              	 .thumb
 665              	 .thumb_func
 667              	mpuGyroInit:
 668              	.LFB547:
 350:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 351:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** void mpuGyroInit(gyroDev_t *gyro)
 352:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 669              	 .loc 1 352 0
 670              	 .cfi_startproc
 671              	 
 672              	 
 673              	 
 674 0000 80B4     	 push {r7}
 675              	.LCFI31:
 676              	 .cfi_def_cfa_offset 4
 677              	 .cfi_offset 7,-4
 678 0002 83B0     	 sub sp,sp,#12
 679              	.LCFI32:
 680              	 .cfi_def_cfa_offset 16
 681 0004 00AF     	 add r7,sp,#0
 682              	.LCFI33:
 683              	 .cfi_def_cfa_register 7
 684 0006 7860     	 str r0,[r7,#4]
 353:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef MPU_INT_EXTI
 354:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     mpuIntExtiInit(gyro);
 355:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #else
 356:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     UNUSED(gyro);
 357:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #endif
 358:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 685              	 .loc 1 358 0
 686 0008 0C37     	 adds r7,r7,#12
 687              	.LCFI34:
 688              	 .cfi_def_cfa_offset 4
 689 000a BD46     	 mov sp,r7
 690              	.LCFI35:
 691              	 .cfi_def_cfa_register 13
 692              	 
 693 000c 5DF8047B 	 ldr r7,[sp],#4
 694              	.LCFI36:
 695              	 .cfi_restore 7
 696              	 .cfi_def_cfa_offset 0
 697 0010 7047     	 bx lr
 698              	 .cfi_endproc
 699              	.LFE547:
 701 0012 00BF     	 .section .text.mpuGyroDLPF,"ax",%progbits
 702              	 .align 2
 703              	 .global mpuGyroDLPF
 704              	 .thumb
 705              	 .thumb_func
 707              	mpuGyroDLPF:
 708              	.LFB548:
 359:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 360:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** uint8_t mpuGyroDLPF(gyroDev_t *gyro)
 361:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 709              	 .loc 1 361 0
 710              	 .cfi_startproc
 711              	 
 712              	 
 713              	 
 714 0000 80B4     	 push {r7}
 715              	.LCFI37:
 716              	 .cfi_def_cfa_offset 4
 717              	 .cfi_offset 7,-4
 718 0002 85B0     	 sub sp,sp,#20
 719              	.LCFI38:
 720              	 .cfi_def_cfa_offset 24
 721 0004 00AF     	 add r7,sp,#0
 722              	.LCFI39:
 723              	 .cfi_def_cfa_register 7
 724 0006 7860     	 str r0,[r7,#4]
 362:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t ret;
 363:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (gyro->gyroRateKHz > GYRO_RATE_8_kHz) {
 725              	 .loc 1 363 0
 726 0008 7B68     	 ldr r3,[r7,#4]
 727 000a 93F85C30 	 ldrb r3,[r3,#92]
 728 000e 032B     	 cmp r3,#3
 729 0010 02D9     	 bls .L40
 364:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         ret = 0;  // If gyro is in 32KHz mode then the DLPF bits aren't used - set to 0
 730              	 .loc 1 364 0
 731 0012 0023     	 movs r3,#0
 732 0014 FB73     	 strb r3,[r7,#15]
 733 0016 14E0     	 b .L41
 734              	.L40:
 365:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     } else {
 366:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         switch (gyro->hardware_lpf) {
 735              	 .loc 1 366 0
 736 0018 7B68     	 ldr r3,[r7,#4]
 737 001a 93F85F30 	 ldrb r3,[r3,#95]
 738 001e 012B     	 cmp r3,#1
 739 0020 06D0     	 beq .L43
 740 0022 022B     	 cmp r3,#2
 741 0024 07D0     	 beq .L44
 742 0026 002B     	 cmp r3,#0
 743 0028 08D1     	 bne .L47
 367:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             case GYRO_HARDWARE_LPF_NORMAL:
 368:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 ret = 0;
 744              	 .loc 1 368 0
 745 002a 0023     	 movs r3,#0
 746 002c FB73     	 strb r3,[r7,#15]
 369:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 break;
 747              	 .loc 1 369 0
 748 002e 08E0     	 b .L41
 749              	.L43:
 370:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             case GYRO_HARDWARE_LPF_EXPERIMENTAL:
 371:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 ret = 7;
 750              	 .loc 1 371 0
 751 0030 0723     	 movs r3,#7
 752 0032 FB73     	 strb r3,[r7,#15]
 372:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 break;
 753              	 .loc 1 372 0
 754 0034 05E0     	 b .L41
 755              	.L44:
 373:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             case GYRO_HARDWARE_LPF_1KHZ_SAMPLE:
 374:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 ret = 1;
 756              	 .loc 1 374 0
 757 0036 0123     	 movs r3,#1
 758 0038 FB73     	 strb r3,[r7,#15]
 375:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 break;
 759              	 .loc 1 375 0
 760 003a 02E0     	 b .L41
 761              	.L47:
 376:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             default:
 377:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 ret = 0;
 762              	 .loc 1 377 0
 763 003c 0023     	 movs r3,#0
 764 003e FB73     	 strb r3,[r7,#15]
 378:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****                 break;
 765              	 .loc 1 378 0
 766 0040 00BF     	 nop
 767              	.L41:
 379:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         }
 380:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 381:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     return ret;
 768              	 .loc 1 381 0
 769 0042 FB7B     	 ldrb r3,[r7,#15]
 382:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 770              	 .loc 1 382 0
 771 0044 1846     	 mov r0,r3
 772 0046 1437     	 adds r7,r7,#20
 773              	.LCFI40:
 774              	 .cfi_def_cfa_offset 4
 775 0048 BD46     	 mov sp,r7
 776              	.LCFI41:
 777              	 .cfi_def_cfa_register 13
 778              	 
 779 004a 5DF8047B 	 ldr r7,[sp],#4
 780              	.LCFI42:
 781              	 .cfi_restore 7
 782              	 .cfi_def_cfa_offset 0
 783 004e 7047     	 bx lr
 784              	 .cfi_endproc
 785              	.LFE548:
 787              	 .section .text.mpuGyroFCHOICE,"ax",%progbits
 788              	 .align 2
 789              	 .global mpuGyroFCHOICE
 790              	 .thumb
 791              	 .thumb_func
 793              	mpuGyroFCHOICE:
 794              	.LFB549:
 383:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 384:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** uint8_t mpuGyroFCHOICE(gyroDev_t *gyro)
 385:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 795              	 .loc 1 385 0
 796              	 .cfi_startproc
 797              	 
 798              	 
 799              	 
 800 0000 80B4     	 push {r7}
 801              	.LCFI43:
 802              	 .cfi_def_cfa_offset 4
 803              	 .cfi_offset 7,-4
 804 0002 83B0     	 sub sp,sp,#12
 805              	.LCFI44:
 806              	 .cfi_def_cfa_offset 16
 807 0004 00AF     	 add r7,sp,#0
 808              	.LCFI45:
 809              	 .cfi_def_cfa_register 7
 810 0006 7860     	 str r0,[r7,#4]
 386:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (gyro->gyroRateKHz > GYRO_RATE_8_kHz) {
 811              	 .loc 1 386 0
 812 0008 7B68     	 ldr r3,[r7,#4]
 813 000a 93F85C30 	 ldrb r3,[r3,#92]
 814 000e 032B     	 cmp r3,#3
 815 0010 08D9     	 bls .L49
 387:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         if (gyro->hardware_32khz_lpf == GYRO_32KHZ_HARDWARE_LPF_EXPERIMENTAL) {
 816              	 .loc 1 387 0
 817 0012 7B68     	 ldr r3,[r7,#4]
 818 0014 93F86030 	 ldrb r3,[r3,#96]
 819 0018 012B     	 cmp r3,#1
 820 001a 01D1     	 bne .L50
 388:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             return FCB_8800_32;
 821              	 .loc 1 388 0
 822 001c 0123     	 movs r3,#1
 823 001e 02E0     	 b .L51
 824              	.L50:
 389:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         } else {
 390:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****             return FCB_3600_32;
 825              	 .loc 1 390 0
 826 0020 0223     	 movs r3,#2
 827 0022 00E0     	 b .L51
 828              	.L49:
 391:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         }
 392:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     } else {
 393:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return FCB_DISABLED;  // Not in 32KHz mode, set FCHOICE to select 8KHz sampling
 829              	 .loc 1 393 0
 830 0024 0023     	 movs r3,#0
 831              	.L51:
 394:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 395:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 832              	 .loc 1 395 0
 833 0026 1846     	 mov r0,r3
 834 0028 0C37     	 adds r7,r7,#12
 835              	.LCFI46:
 836              	 .cfi_def_cfa_offset 4
 837 002a BD46     	 mov sp,r7
 838              	.LCFI47:
 839              	 .cfi_def_cfa_register 13
 840              	 
 841 002c 5DF8047B 	 ldr r7,[sp],#4
 842              	.LCFI48:
 843              	 .cfi_restore 7
 844              	 .cfi_def_cfa_offset 0
 845 0030 7047     	 bx lr
 846              	 .cfi_endproc
 847              	.LFE549:
 849 0032 00BF     	 .section .text.mpuGyroReadRegister,"ax",%progbits
 850              	 .align 2
 851              	 .global mpuGyroReadRegister
 852              	 .thumb
 853              	 .thumb_func
 855              	mpuGyroReadRegister:
 856              	.LFB550:
 396:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 397:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** #ifdef USE_GYRO_REGISTER_DUMP
 398:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** uint8_t mpuGyroReadRegister(const busDevice_t *bus, uint8_t reg)
 399:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** {
 857              	 .loc 1 399 0
 858              	 .cfi_startproc
 859              	 
 860              	 
 861 0000 80B5     	 push {r7,lr}
 862              	.LCFI49:
 863              	 .cfi_def_cfa_offset 8
 864              	 .cfi_offset 7,-8
 865              	 .cfi_offset 14,-4
 866 0002 84B0     	 sub sp,sp,#16
 867              	.LCFI50:
 868              	 .cfi_def_cfa_offset 24
 869 0004 00AF     	 add r7,sp,#0
 870              	.LCFI51:
 871              	 .cfi_def_cfa_register 7
 872 0006 7860     	 str r0,[r7,#4]
 873 0008 0B46     	 mov r3,r1
 874 000a FB70     	 strb r3,[r7,#3]
 400:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     uint8_t data;
 401:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     const bool ack = busReadRegisterBuffer(bus, reg, &data, 1);
 875              	 .loc 1 401 0
 876 000c FA78     	 ldrb r2,[r7,#3]
 877 000e 07F10E03 	 add r3,r7,#14
 878 0012 7868     	 ldr r0,[r7,#4]
 879 0014 1146     	 mov r1,r2
 880 0016 1A46     	 mov r2,r3
 881 0018 0123     	 movs r3,#1
 882 001a FFF7FEFF 	 bl busReadRegisterBuffer
 883 001e 0346     	 mov r3,r0
 884 0020 FB73     	 strb r3,[r7,#15]
 402:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     if (ack) {
 885              	 .loc 1 402 0
 886 0022 FB7B     	 ldrb r3,[r7,#15]
 887 0024 002B     	 cmp r3,#0
 888 0026 01D0     	 beq .L53
 403:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return data;
 889              	 .loc 1 403 0
 890 0028 BB7B     	 ldrb r3,[r7,#14]
 891 002a 00E0     	 b .L55
 892              	.L53:
 404:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     } else {
 405:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****         return 0;
 893              	 .loc 1 405 0
 894 002c 0023     	 movs r3,#0
 895              	.L55:
 406:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c ****     }
 407:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** 
 408:../cleanflight/src/main/drivers/accgyro/accgyro_mpu.c **** }
 896              	 .loc 1 408 0 discriminator 1
 897 002e 1846     	 mov r0,r3
 898 0030 1037     	 adds r7,r7,#16
 899              	.LCFI52:
 900              	 .cfi_def_cfa_offset 8
 901 0032 BD46     	 mov sp,r7
 902              	.LCFI53:
 903              	 .cfi_def_cfa_register 13
 904              	 
 905 0034 80BD     	 pop {r7,pc}
 906              	 .cfi_endproc
 907              	.LFE550:
 909 0036 00BF     	 .section .rodata.dataToSend.12879,"a",%progbits
 910              	 .align 2
 913              	dataToSend.12879:
 914 0000 C3       	 .byte -61
 915 0001 FF       	 .byte -1
 916 0002 FF       	 .byte -1
 917 0003 FF       	 .byte -1
 918 0004 FF       	 .byte -1
 919 0005 FF       	 .byte -1
 920 0006 FF       	 .byte -1
 921 0007 00       	 .text
 922              	.Letext0:
 923              	 .file 2 "d:\\xmc\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 924              	 .file 3 "d:\\xmc\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 925              	 .file 4 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/lib/main/XMC4000/xmc4700.h"
 926              	 .file 5 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/lib/main/XMC4000/XMCLib/inc/xmc_usic.h"
 927              	 .file 6 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/platform.h"
 928              	 .file 7 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/io_types.h"
 929              	 .file 8 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/bus_i2c.h"
 930              	 .file 9 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/build/debug.h"
 931              	 .file 10 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/bus.h"
 932              	 .file 11 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/exti.h"
 933              	 .file 12 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/resource.h"
 934              	 .file 13 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/sensor.h"
 935              	 .file 14 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/accgyro/accgyro.h"
 936              	 .file 15 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/system.h"
 937              	 .file 16 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/common/time.h"
 938              	 .file 17 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/common/axis.h"
 939              	 .file 18 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/drivers/accgyro/accgyro_mpu.h"
 940              	 .file 19 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/src/main/sensors/gyro.h"
 941              	 .file 20 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/lib/main/CMSIS/Core/Include/core_cm4.h"
 942              	 .file 21 "D:/XMC/Projekte/Temp/CF_XMC4700/cleanflight/lib/main/XMC4000/system_XMC4700.h"
DEFINED SYMBOLS
                            *ABS*:00000000 accgyro_mpu.c
                            *COM*:00000004 mpuResetFn
    {standard input}:21     .text.mpu6050FindRevision:00000000 $t
    {standard input}:25     .text.mpu6050FindRevision:00000000 mpu6050FindRevision
    {standard input}:185    .text.mpuAccRead:00000000 $t
    {standard input}:190    .text.mpuAccRead:00000000 mpuAccRead
    {standard input}:276    .text.mpuGyroRead:00000000 $t
    {standard input}:281    .text.mpuGyroRead:00000000 mpuGyroRead
    {standard input}:367    .text.mpuGyroReadSPI:00000000 $t
    {standard input}:372    .text.mpuGyroReadSPI:00000000 mpuGyroReadSPI
    {standard input}:457    .text.mpuGyroReadSPI:00000078 $d
    {standard input}:913    .rodata.dataToSend.12879:00000000 dataToSend.12879
    {standard input}:462    .text.detectSPISensorsAndUpdateDetectionResult:00000000 $t
    {standard input}:466    .text.detectSPISensorsAndUpdateDetectionResult:00000000 detectSPISensorsAndUpdateDetectionResult
    {standard input}:507    .text.mpuDetect:00000000 $t
    {standard input}:512    .text.mpuDetect:00000000 mpuDetect
    {standard input}:662    .text.mpuGyroInit:00000000 $t
    {standard input}:667    .text.mpuGyroInit:00000000 mpuGyroInit
    {standard input}:702    .text.mpuGyroDLPF:00000000 $t
    {standard input}:707    .text.mpuGyroDLPF:00000000 mpuGyroDLPF
    {standard input}:788    .text.mpuGyroFCHOICE:00000000 $t
    {standard input}:793    .text.mpuGyroFCHOICE:00000000 mpuGyroFCHOICE
    {standard input}:850    .text.mpuGyroReadRegister:00000000 $t
    {standard input}:855    .text.mpuGyroReadRegister:00000000 mpuGyroReadRegister
    {standard input}:910    .rodata.dataToSend.12879:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
busReadRegisterBuffer
failureMode
spiBusTransfer
delay
