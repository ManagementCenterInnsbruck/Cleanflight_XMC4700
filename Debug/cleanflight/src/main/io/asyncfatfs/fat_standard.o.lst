   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "fat_standard.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.fat16_isEndOfChainMarker,"ax",%progbits
  20              	 .align 2
  21              	 .global fat16_isEndOfChainMarker
  22              	 .thumb
  23              	 .thumb_func
  25              	fat16_isEndOfChainMarker:
  26              	.LFB0:
  27              	 .file 1 "../cleanflight/src/main/io/asyncfatfs/fat_standard.c"
   1:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** /*
   2:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * This file is part of Cleanflight and Betaflight.
   3:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  *
   4:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * Cleanflight and Betaflight are free software. You can redistribute
   5:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * this software and/or modify this software under the terms of the
   6:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * GNU General Public License as published by the Free Software
   7:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * Foundation, either version 3 of the License, or (at your option)
   8:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * any later version.
   9:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  *
  10:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * Cleanflight and Betaflight are distributed in the hope that they
  11:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * will be useful, but WITHOUT ANY WARRANTY; without even the implied
  12:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  13:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * See the GNU General Public License for more details.
  14:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  *
  15:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * You should have received a copy of the GNU General Public License
  16:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * along with this software.
  17:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  *
  18:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * If not, see <http://www.gnu.org/licenses/>.
  19:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  */
  20:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  21:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** #include <ctype.h>
  22:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  23:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** #include "fat_standard.h"
  24:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  25:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** bool fat16_isEndOfChainMarker(uint16_t clusterNumber)
  26:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
  28              	 .loc 1 26 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32              	 
  33 0000 80B4     	 push {r7}
  34              	.LCFI0:
  35              	 .cfi_def_cfa_offset 4
  36              	 .cfi_offset 7,-4
  37 0002 83B0     	 sub sp,sp,#12
  38              	.LCFI1:
  39              	 .cfi_def_cfa_offset 16
  40 0004 00AF     	 add r7,sp,#0
  41              	.LCFI2:
  42              	 .cfi_def_cfa_register 7
  43 0006 0346     	 mov r3,r0
  44 0008 FB80     	 strh r3,[r7,#6]
  27:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     return clusterNumber >= 0xFFF8;
  45              	 .loc 1 27 0
  46 000a FB88     	 ldrh r3,[r7,#6]
  47 000c 4FF6F772 	 movw r2,#65527
  48 0010 9342     	 cmp r3,r2
  49 0012 8CBF     	 ite hi
  50 0014 0123     	 movhi r3,#1
  51 0016 0023     	 movls r3,#0
  52 0018 DBB2     	 uxtb r3,r3
  28:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
  53              	 .loc 1 28 0
  54 001a 1846     	 mov r0,r3
  55 001c 0C37     	 adds r7,r7,#12
  56              	.LCFI3:
  57              	 .cfi_def_cfa_offset 4
  58 001e BD46     	 mov sp,r7
  59              	.LCFI4:
  60              	 .cfi_def_cfa_register 13
  61              	 
  62 0020 5DF8047B 	 ldr r7,[sp],#4
  63              	.LCFI5:
  64              	 .cfi_restore 7
  65              	 .cfi_def_cfa_offset 0
  66 0024 7047     	 bx lr
  67              	 .cfi_endproc
  68              	.LFE0:
  70              	 .section .text.fat32_isEndOfChainMarker,"ax",%progbits
  71              	 .align 2
  72              	 .global fat32_isEndOfChainMarker
  73              	 .thumb
  74              	 .thumb_func
  76              	fat32_isEndOfChainMarker:
  77              	.LFB1:
  29:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  30:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** // Pass the cluster number after fat32_decodeClusterNumber().
  31:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** bool fat32_isEndOfChainMarker(uint32_t clusterNumber)
  32:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
  78              	 .loc 1 32 0
  79              	 .cfi_startproc
  80              	 
  81              	 
  82              	 
  83 0000 80B4     	 push {r7}
  84              	.LCFI6:
  85              	 .cfi_def_cfa_offset 4
  86              	 .cfi_offset 7,-4
  87 0002 83B0     	 sub sp,sp,#12
  88              	.LCFI7:
  89              	 .cfi_def_cfa_offset 16
  90 0004 00AF     	 add r7,sp,#0
  91              	.LCFI8:
  92              	 .cfi_def_cfa_register 7
  93 0006 7860     	 str r0,[r7,#4]
  33:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     return clusterNumber >= 0x0FFFFFF8;
  94              	 .loc 1 33 0
  95 0008 7B68     	 ldr r3,[r7,#4]
  96 000a 064A     	 ldr r2,.L5
  97 000c 9342     	 cmp r3,r2
  98 000e 8CBF     	 ite hi
  99 0010 0123     	 movhi r3,#1
 100 0012 0023     	 movls r3,#0
 101 0014 DBB2     	 uxtb r3,r3
  34:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
 102              	 .loc 1 34 0
 103 0016 1846     	 mov r0,r3
 104 0018 0C37     	 adds r7,r7,#12
 105              	.LCFI9:
 106              	 .cfi_def_cfa_offset 4
 107 001a BD46     	 mov sp,r7
 108              	.LCFI10:
 109              	 .cfi_def_cfa_register 13
 110              	 
 111 001c 5DF8047B 	 ldr r7,[sp],#4
 112              	.LCFI11:
 113              	 .cfi_restore 7
 114              	 .cfi_def_cfa_offset 0
 115 0020 7047     	 bx lr
 116              	.L6:
 117 0022 00BF     	 .align 2
 118              	.L5:
 119 0024 F7FFFF0F 	 .word 268435447
 120              	 .cfi_endproc
 121              	.LFE1:
 123              	 .section .text.fat32_decodeClusterNumber,"ax",%progbits
 124              	 .align 2
 125              	 .global fat32_decodeClusterNumber
 126              	 .thumb
 127              	 .thumb_func
 129              	fat32_decodeClusterNumber:
 130              	.LFB2:
  35:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  36:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** /**
  37:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * FAT32 cluster numbers are really only 28 bits, and the top 4 bits must be left alone and not tre
  38:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * cluster number (so various FAT drivers can use those bits for their own purposes, or they can be
  39:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * extensions)
  40:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  */
  41:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** uint32_t fat32_decodeClusterNumber(uint32_t clusterNumber)
  42:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
 131              	 .loc 1 42 0
 132              	 .cfi_startproc
 133              	 
 134              	 
 135              	 
 136 0000 80B4     	 push {r7}
 137              	.LCFI12:
 138              	 .cfi_def_cfa_offset 4
 139              	 .cfi_offset 7,-4
 140 0002 83B0     	 sub sp,sp,#12
 141              	.LCFI13:
 142              	 .cfi_def_cfa_offset 16
 143 0004 00AF     	 add r7,sp,#0
 144              	.LCFI14:
 145              	 .cfi_def_cfa_register 7
 146 0006 7860     	 str r0,[r7,#4]
  43:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     return clusterNumber & 0x0FFFFFFF;
 147              	 .loc 1 43 0
 148 0008 7B68     	 ldr r3,[r7,#4]
 149 000a 23F07043 	 bic r3,r3,#-268435456
  44:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
 150              	 .loc 1 44 0
 151 000e 1846     	 mov r0,r3
 152 0010 0C37     	 adds r7,r7,#12
 153              	.LCFI15:
 154              	 .cfi_def_cfa_offset 4
 155 0012 BD46     	 mov sp,r7
 156              	.LCFI16:
 157              	 .cfi_def_cfa_register 13
 158              	 
 159 0014 5DF8047B 	 ldr r7,[sp],#4
 160              	.LCFI17:
 161              	 .cfi_restore 7
 162              	 .cfi_def_cfa_offset 0
 163 0018 7047     	 bx lr
 164              	 .cfi_endproc
 165              	.LFE2:
 167 001a 00BF     	 .section .text.fat_isFreeSpace,"ax",%progbits
 168              	 .align 2
 169              	 .global fat_isFreeSpace
 170              	 .thumb
 171              	 .thumb_func
 173              	fat_isFreeSpace:
 174              	.LFB3:
  45:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  46:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** // fat32 needs fat32_decodeClusterNumber() applied first.
  47:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** bool fat_isFreeSpace(uint32_t clusterNumber)
  48:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
 175              	 .loc 1 48 0
 176              	 .cfi_startproc
 177              	 
 178              	 
 179              	 
 180 0000 80B4     	 push {r7}
 181              	.LCFI18:
 182              	 .cfi_def_cfa_offset 4
 183              	 .cfi_offset 7,-4
 184 0002 83B0     	 sub sp,sp,#12
 185              	.LCFI19:
 186              	 .cfi_def_cfa_offset 16
 187 0004 00AF     	 add r7,sp,#0
 188              	.LCFI20:
 189              	 .cfi_def_cfa_register 7
 190 0006 7860     	 str r0,[r7,#4]
  49:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     return clusterNumber == 0;
 191              	 .loc 1 49 0
 192 0008 7B68     	 ldr r3,[r7,#4]
 193 000a 002B     	 cmp r3,#0
 194 000c 0CBF     	 ite eq
 195 000e 0123     	 moveq r3,#1
 196 0010 0023     	 movne r3,#0
 197 0012 DBB2     	 uxtb r3,r3
  50:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
 198              	 .loc 1 50 0
 199 0014 1846     	 mov r0,r3
 200 0016 0C37     	 adds r7,r7,#12
 201              	.LCFI21:
 202              	 .cfi_def_cfa_offset 4
 203 0018 BD46     	 mov sp,r7
 204              	.LCFI22:
 205              	 .cfi_def_cfa_register 13
 206              	 
 207 001a 5DF8047B 	 ldr r7,[sp],#4
 208              	.LCFI23:
 209              	 .cfi_restore 7
 210              	 .cfi_def_cfa_offset 0
 211 001e 7047     	 bx lr
 212              	 .cfi_endproc
 213              	.LFE3:
 215              	 .section .text.fat_isDirectoryEntryTerminator,"ax",%progbits
 216              	 .align 2
 217              	 .global fat_isDirectoryEntryTerminator
 218              	 .thumb
 219              	 .thumb_func
 221              	fat_isDirectoryEntryTerminator:
 222              	.LFB4:
  51:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  52:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** bool fat_isDirectoryEntryTerminator(fatDirectoryEntry_t *entry)
  53:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
 223              	 .loc 1 53 0
 224              	 .cfi_startproc
 225              	 
 226              	 
 227              	 
 228 0000 80B4     	 push {r7}
 229              	.LCFI24:
 230              	 .cfi_def_cfa_offset 4
 231              	 .cfi_offset 7,-4
 232 0002 83B0     	 sub sp,sp,#12
 233              	.LCFI25:
 234              	 .cfi_def_cfa_offset 16
 235 0004 00AF     	 add r7,sp,#0
 236              	.LCFI26:
 237              	 .cfi_def_cfa_register 7
 238 0006 7860     	 str r0,[r7,#4]
  54:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     return entry->filename[0] == 0x00;
 239              	 .loc 1 54 0
 240 0008 7B68     	 ldr r3,[r7,#4]
 241 000a 1B78     	 ldrb r3,[r3]
 242 000c 002B     	 cmp r3,#0
 243 000e 0CBF     	 ite eq
 244 0010 0123     	 moveq r3,#1
 245 0012 0023     	 movne r3,#0
 246 0014 DBB2     	 uxtb r3,r3
  55:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
 247              	 .loc 1 55 0
 248 0016 1846     	 mov r0,r3
 249 0018 0C37     	 adds r7,r7,#12
 250              	.LCFI27:
 251              	 .cfi_def_cfa_offset 4
 252 001a BD46     	 mov sp,r7
 253              	.LCFI28:
 254              	 .cfi_def_cfa_register 13
 255              	 
 256 001c 5DF8047B 	 ldr r7,[sp],#4
 257              	.LCFI29:
 258              	 .cfi_restore 7
 259              	 .cfi_def_cfa_offset 0
 260 0020 7047     	 bx lr
 261              	 .cfi_endproc
 262              	.LFE4:
 264 0022 00BF     	 .section .text.fat_isDirectoryEntryEmpty,"ax",%progbits
 265              	 .align 2
 266              	 .global fat_isDirectoryEntryEmpty
 267              	 .thumb
 268              	 .thumb_func
 270              	fat_isDirectoryEntryEmpty:
 271              	.LFB5:
  56:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  57:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** bool fat_isDirectoryEntryEmpty(fatDirectoryEntry_t *entry)
  58:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
 272              	 .loc 1 58 0
 273              	 .cfi_startproc
 274              	 
 275              	 
 276              	 
 277 0000 80B4     	 push {r7}
 278              	.LCFI30:
 279              	 .cfi_def_cfa_offset 4
 280              	 .cfi_offset 7,-4
 281 0002 83B0     	 sub sp,sp,#12
 282              	.LCFI31:
 283              	 .cfi_def_cfa_offset 16
 284 0004 00AF     	 add r7,sp,#0
 285              	.LCFI32:
 286              	 .cfi_def_cfa_register 7
 287 0006 7860     	 str r0,[r7,#4]
  59:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     return (unsigned char) entry->filename[0] == FAT_DELETED_FILE_MARKER;
 288              	 .loc 1 59 0
 289 0008 7B68     	 ldr r3,[r7,#4]
 290 000a 1B78     	 ldrb r3,[r3]
 291 000c E52B     	 cmp r3,#229
 292 000e 0CBF     	 ite eq
 293 0010 0123     	 moveq r3,#1
 294 0012 0023     	 movne r3,#0
 295 0014 DBB2     	 uxtb r3,r3
  60:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
 296              	 .loc 1 60 0
 297 0016 1846     	 mov r0,r3
 298 0018 0C37     	 adds r7,r7,#12
 299              	.LCFI33:
 300              	 .cfi_def_cfa_offset 4
 301 001a BD46     	 mov sp,r7
 302              	.LCFI34:
 303              	 .cfi_def_cfa_register 13
 304              	 
 305 001c 5DF8047B 	 ldr r7,[sp],#4
 306              	.LCFI35:
 307              	 .cfi_restore 7
 308              	 .cfi_def_cfa_offset 0
 309 0020 7047     	 bx lr
 310              	 .cfi_endproc
 311              	.LFE5:
 313 0022 00BF     	 .section .text.fat_convertFilenameToFATStyle,"ax",%progbits
 314              	 .align 2
 315              	 .global fat_convertFilenameToFATStyle
 316              	 .thumb
 317              	 .thumb_func
 319              	fat_convertFilenameToFATStyle:
 320              	.LFB6:
  61:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  62:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** /**
  63:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * Convert the given "prefix.ext" style filename to the FAT format to be stored on disk.
  64:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  *
  65:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  * fatFilename must point to a buffer which is FAT_FILENAME_LENGTH bytes long. The buffer is not nu
  66:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****  */
  67:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** void fat_convertFilenameToFATStyle(const char *filename, uint8_t *fatFilename)
  68:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** {
 321              	 .loc 1 68 0
 322              	 .cfi_startproc
 323              	 
 324              	 
 325 0000 80B5     	 push {r7,lr}
 326              	.LCFI36:
 327              	 .cfi_def_cfa_offset 8
 328              	 .cfi_offset 7,-8
 329              	 .cfi_offset 14,-4
 330 0002 84B0     	 sub sp,sp,#16
 331              	.LCFI37:
 332              	 .cfi_def_cfa_offset 24
 333 0004 00AF     	 add r7,sp,#0
 334              	.LCFI38:
 335              	 .cfi_def_cfa_register 7
 336 0006 7860     	 str r0,[r7,#4]
 337 0008 3960     	 str r1,[r7]
 338              	.LBB2:
  69:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     for (int i = 0; i < 8; i++) {
 339              	 .loc 1 69 0
 340 000a 0023     	 movs r3,#0
 341 000c FB60     	 str r3,[r7,#12]
 342 000e 1DE0     	 b .L16
 343              	.L20:
  70:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         if (*filename == '\0' || *filename == '.') {
 344              	 .loc 1 70 0
 345 0010 7B68     	 ldr r3,[r7,#4]
 346 0012 1B78     	 ldrb r3,[r3]
 347 0014 002B     	 cmp r3,#0
 348 0016 03D0     	 beq .L17
 349              	 .loc 1 70 0 is_stmt 0 discriminator 1
 350 0018 7B68     	 ldr r3,[r7,#4]
 351 001a 1B78     	 ldrb r3,[r3]
 352 001c 2E2B     	 cmp r3,#46
 353 001e 03D1     	 bne .L18
 354              	.L17:
  71:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****             *fatFilename = ' ';
 355              	 .loc 1 71 0 is_stmt 1
 356 0020 3B68     	 ldr r3,[r7]
 357 0022 2022     	 movs r2,#32
 358 0024 1A70     	 strb r2,[r3]
 359 0026 0BE0     	 b .L19
 360              	.L18:
  72:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         } else {
  73:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****             *fatFilename = toupper((unsigned char)*filename);
 361              	 .loc 1 73 0
 362 0028 7B68     	 ldr r3,[r7,#4]
 363 002a 1B78     	 ldrb r3,[r3]
 364 002c 1846     	 mov r0,r3
 365 002e FFF7FEFF 	 bl toupper
 366 0032 0346     	 mov r3,r0
 367 0034 DAB2     	 uxtb r2,r3
 368 0036 3B68     	 ldr r3,[r7]
 369 0038 1A70     	 strb r2,[r3]
  74:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****             filename++;
 370              	 .loc 1 74 0
 371 003a 7B68     	 ldr r3,[r7,#4]
 372 003c 0133     	 adds r3,r3,#1
 373 003e 7B60     	 str r3,[r7,#4]
 374              	.L19:
  75:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         }
  76:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         fatFilename++;
 375              	 .loc 1 76 0 discriminator 2
 376 0040 3B68     	 ldr r3,[r7]
 377 0042 0133     	 adds r3,r3,#1
 378 0044 3B60     	 str r3,[r7]
  69:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         if (*filename == '\0' || *filename == '.') {
 379              	 .loc 1 69 0 discriminator 2
 380 0046 FB68     	 ldr r3,[r7,#12]
 381 0048 0133     	 adds r3,r3,#1
 382 004a FB60     	 str r3,[r7,#12]
 383              	.L16:
  69:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         if (*filename == '\0' || *filename == '.') {
 384              	 .loc 1 69 0 is_stmt 0 discriminator 1
 385 004c FB68     	 ldr r3,[r7,#12]
 386 004e 072B     	 cmp r3,#7
 387 0050 DEDD     	 ble .L20
 388              	.LBE2:
  77:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     }
  78:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  79:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     if (*filename == '.') {
 389              	 .loc 1 79 0 is_stmt 1
 390 0052 7B68     	 ldr r3,[r7,#4]
 391 0054 1B78     	 ldrb r3,[r3]
 392 0056 2E2B     	 cmp r3,#46
 393 0058 02D1     	 bne .L21
  80:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****         filename++;
 394              	 .loc 1 80 0
 395 005a 7B68     	 ldr r3,[r7,#4]
 396 005c 0133     	 adds r3,r3,#1
 397 005e 7B60     	 str r3,[r7,#4]
 398              	.L21:
 399              	.LBB3:
  81:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     }
  82:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** 
  83:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****     for (int i = 0; i < 3; i++) {
 400              	 .loc 1 83 0
 401 0060 0023     	 movs r3,#0
 402 0062 BB60     	 str r3,[r7,#8]
 403 0064 19E0     	 b .L22
 404              	.L25:
  84:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****          if (*filename == '\0') {
 405              	 .loc 1 84 0
 406 0066 7B68     	 ldr r3,[r7,#4]
 407 0068 1B78     	 ldrb r3,[r3]
 408 006a 002B     	 cmp r3,#0
 409 006c 03D1     	 bne .L23
  85:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****              *fatFilename = ' ';
 410              	 .loc 1 85 0
 411 006e 3B68     	 ldr r3,[r7]
 412 0070 2022     	 movs r2,#32
 413 0072 1A70     	 strb r2,[r3]
 414 0074 0BE0     	 b .L24
 415              	.L23:
  86:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****          } else {
  87:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****              *fatFilename = toupper((unsigned char)*filename);
 416              	 .loc 1 87 0
 417 0076 7B68     	 ldr r3,[r7,#4]
 418 0078 1B78     	 ldrb r3,[r3]
 419 007a 1846     	 mov r0,r3
 420 007c FFF7FEFF 	 bl toupper
 421 0080 0346     	 mov r3,r0
 422 0082 DAB2     	 uxtb r2,r3
 423 0084 3B68     	 ldr r3,[r7]
 424 0086 1A70     	 strb r2,[r3]
  88:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****              filename++;
 425              	 .loc 1 88 0
 426 0088 7B68     	 ldr r3,[r7,#4]
 427 008a 0133     	 adds r3,r3,#1
 428 008c 7B60     	 str r3,[r7,#4]
 429              	.L24:
  89:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****          }
  90:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****          fatFilename++;
 430              	 .loc 1 90 0 discriminator 2
 431 008e 3B68     	 ldr r3,[r7]
 432 0090 0133     	 adds r3,r3,#1
 433 0092 3B60     	 str r3,[r7]
  83:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****          if (*filename == '\0') {
 434              	 .loc 1 83 0 discriminator 2
 435 0094 BB68     	 ldr r3,[r7,#8]
 436 0096 0133     	 adds r3,r3,#1
 437 0098 BB60     	 str r3,[r7,#8]
 438              	.L22:
  83:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****          if (*filename == '\0') {
 439              	 .loc 1 83 0 is_stmt 0 discriminator 1
 440 009a BB68     	 ldr r3,[r7,#8]
 441 009c 022B     	 cmp r3,#2
 442 009e E2DD     	 ble .L25
 443              	.LBE3:
  91:../cleanflight/src/main/io/asyncfatfs/fat_standard.c ****      }
  92:../cleanflight/src/main/io/asyncfatfs/fat_standard.c **** }
 444              	 .loc 1 92 0 is_stmt 1
 445 00a0 1037     	 adds r7,r7,#16
 446              	.LCFI39:
 447              	 .cfi_def_cfa_offset 8
 448 00a2 BD46     	 mov sp,r7
 449              	.LCFI40:
 450              	 .cfi_def_cfa_register 13
 451              	 
 452 00a4 80BD     	 pop {r7,pc}
 453              	 .cfi_endproc
 454              	.LFE6:
 456 00a6 00BF     	 .text
 457              	.Letext0:
 458              	 .file 2 "d:\\xmc\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 459              	 .file 3 "d:\\xmc\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 460              	 .file 4 "../cleanflight/src/main/io/asyncfatfs/fat_standard.h"
DEFINED SYMBOLS
                            *ABS*:00000000 fat_standard.c
    {standard input}:20     .text.fat16_isEndOfChainMarker:00000000 $t
    {standard input}:25     .text.fat16_isEndOfChainMarker:00000000 fat16_isEndOfChainMarker
    {standard input}:71     .text.fat32_isEndOfChainMarker:00000000 $t
    {standard input}:76     .text.fat32_isEndOfChainMarker:00000000 fat32_isEndOfChainMarker
    {standard input}:119    .text.fat32_isEndOfChainMarker:00000024 $d
    {standard input}:124    .text.fat32_decodeClusterNumber:00000000 $t
    {standard input}:129    .text.fat32_decodeClusterNumber:00000000 fat32_decodeClusterNumber
    {standard input}:168    .text.fat_isFreeSpace:00000000 $t
    {standard input}:173    .text.fat_isFreeSpace:00000000 fat_isFreeSpace
    {standard input}:216    .text.fat_isDirectoryEntryTerminator:00000000 $t
    {standard input}:221    .text.fat_isDirectoryEntryTerminator:00000000 fat_isDirectoryEntryTerminator
    {standard input}:265    .text.fat_isDirectoryEntryEmpty:00000000 $t
    {standard input}:270    .text.fat_isDirectoryEntryEmpty:00000000 fat_isDirectoryEntryEmpty
    {standard input}:314    .text.fat_convertFilenameToFATStyle:00000000 $t
    {standard input}:319    .text.fat_convertFilenameToFATStyle:00000000 fat_convertFilenameToFATStyle
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
toupper
